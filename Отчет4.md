# Отчет по лабораторной работе №4

## Цель работы: изучение методов работы компонентов PWA приложений.

## 1. Service Worker
В ходе выполнения задания было проведено ознакомление с работой Service Worker. Было изучено тестовое приложение sw-test, код которого находится в ветке ToolsPWApplication.

**Ответы на вопросы:**

* Какие технологии лежат в основе Service Worker?

Service Worker представляет собой JavaScript-файл, который может контролировать веб-страницу или сайт, с которым он ассоциируется, перехватывать и модифицировать запросы навигации и ресурсов,  гибко кешировать ресурсы для предоставления полного контроля над тем, как приложение ведет себя в определенных ситуациях.

* Как работает Service Worker?

Сначала веб-страница регистрирует service worker, используя .js-файл, содержащий код сервис-воркера. Service worker устанавливается, активируется и начинает в фоновом режиме прослушивать события "fetch" и "message" и при необходимости их изменять или отменять совсем. Также при обработке события install в коде сервис-воркера происходит открытие кэша и кэширование необходимых материалов.

* Возможно ли проксирование запросов с разных удаленных серверов с разными IP адресами? Почему и как можно реализовать?

Нет, Service Worker работает только с тем адресом, с которого загружен его код. То есть можно перехватывать только запросы к своему домену. Невозможно, например, сконфигурировать несколько Web-серверов с разными IP-адресами — для этого придется менять порт Web-сервера по умолчанию и при обращении по 80-му порту в настройке маршрутизатора в качестве Private Port указывать измененный порт Web-сервера.

* Сохраняется ли проксированный контент? Как настроить сохранение запросов в ServiceWoker?

Если запрос выполняется впервые, Service Worker дает ему дойти до сервера и сохраняет полученный ответ. При последующем таком запросе скрипт уже сам отдаст данные из кэша.

* Какие есть ограничения в работе Service Woker?

Работа только на localhost либо по протоколу HTTPS, поддерживаемость далеко не всеми браузерами, а также необходимость заново загружать контент как минимум каждые 24 часа, чтобы предотвратить использование старой версии кода клиентом.

## 2. IndexedDB

**Ответы на вопросы:**

* Каким типом хранилища является IndexedDB?

IndexedDB является стандартом хранения структурированных данных на стороне клиента типа ключ/значенийе (база данных noSQL), которое считается окончательным решением для хранения данных в браузерах.

* Какая последовательность работы с хранилищем?

Обычная последовательность шагов при работе с IndexedDB :

1. Открыть базу данных.
2. Создать хранилище объектов в базе данных, над которой будут выполняться наши операции.
3. Запустить транзакцию и выдать запрос на выполнение какой-либо операции с базой данных, например, добавление или извлечение данных.
4. Ждать завершения операции, “слушая” событие DOM, на которое должен быть установлен обработчик.
5. Сделать что-то с результатами (которые могут быть найдены в возвращаемом по нашему запросу объекте).

* Какой жизненный цикл хранилища?

Открытие БД -> Создание хранилища -> Некоторая работа -> Удаление хранилища -> Удаление БД.

* Будет ли доступна информация из хранилища при закрытии веб-приложения? Если нет – какой тип хранилища надо использовать?

Да, будет, так как база данных хранится локально, и поэтому при отсутствии сети пользователь может получить эти локально сохраненные данные.

* Будет ли доступно хранилище двум одновременно открытым экземплярам веб-приложения? Почему?

Концепция IndexedDB гарантирует атомарность транзакций. К тому же данное хранилище - асинхронное. Всё это позволяет поддерживать доступность хранилища двум и более одновременно открытым экземплярам приложения.

## 3. LocalStorage, sessionStorage

**Ответы на вопросы:**

* Каким типом хранилища является LocalStorage и sessionStorage?

LocalStorage и sessionStorage также хранят данные в браузере по типу ключ/значение.

* Какая последовательность работы с хранилищем?

1. Сохранить пару/ключ значение: setItem(key, value).
2. Получить данные по ключу key: getItem(key).
3. Удалить данные по ключу key: removeItem(key), полная очистка с помощью метода clear().

* Какой жизненный цикл хранилища?

Данные, которые записаны в sessionStorage, сохраняются после обновления страницы, а данные, записанные в localStorage - даже после перезапуска браузера и ОС.

* Будет ли доступна информация из хранилища при закрытии веб-приложения? Если нет – какой тип хранилища надо использовать?

Да, но только данные, записанные в localStorage, поскольку они сохраняются даже после перезапуска браузера и даже ОС. Данные, записанные в sessionStorage, не сохранятся после закрытия приложения.

* Будет ли доступно хранилище двум одновременно открытым экземплярам веб-приложения? Почему?

Да, так как хранилище localStorage привязано к источнику (домен/протокол/порт). 

## 4. Push Notification
В ходе выполнения задания было проведено ознакомление с работой уведомлений. После чего дополнено разработанное приложение в практическом задании push-уведомлениями. Требования к ним:

* случайное время уведомления;
* случайный текст на уведомлении;
* уведомления являются периодичными;
* уведомления хранятся в локально;
* код находится в ветке ToolsPWApplication.

Пример push-уведомления, а также локальное хранение уведомлений продемонстрировано на рисунках ниже.
<p align=center>
  <img src="https://sun9-4.userapi.com/IZGoHqfCjL6BWV5WmKvobWCtLFWeQCHDruvSGg/G6AI2rK9ihk.jpg">
</p>
