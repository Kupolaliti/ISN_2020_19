# Отчет по лабораторной работе №4

## Цель работы: изучение методов работы компонентов PWA приложений.

## 1. Service Worker
В ходе выполнения задания было проведено ознакомление с работой Service Worker. Было изучено тестовое приложение sw-test, код которого находится в ветке ToolsPWApplication.

**Ответы на вопросы:**

* Какие технологии лежат в основе Service Worker?

Service Worker представляет собой JavaScript-файл, который может контролировать веб-страницу или сайт, с которым он ассоциируется, перехватывать и модифицировать запросы навигации и ресурсов,  гибко кешировать ресурсы для предоставления полного контроля над тем, как приложение ведет себя в определенных ситуациях.

* Как работает Service Worker?

Сначала веб-страница регистрирует service worker, используя .js-файл, содержащий код сервис-воркера. Service worker устанавливается, активируется и начинает в фоновом режиме прослушивать события "fetch" и "message" и при необходимости их изменять или отменять совсем. Также при обработке события install в коде сервис-воркера происходит открытие кэша и кэширование необходимых материалов.

* Возможно ли проксирование запросов с разных удаленных серверов с разными IP адресами? Почему и как можно реализовать?

Нет, Service Worker работает только с тем адресом, с которого загружен его код. То есть можно перехватывать только запросы к своему домену. Невозможно, например, сконфигурировать несколько Web-серверов с разными IP-адресами — для этого придется менять порт Web-сервера по умолчанию и при обращении по 80-му порту в настройке маршрутизатора в качестве Private Port указывать измененный порт Web-сервера.

* Сохраняется ли проксированный контент? Как настроить сохранение запросов в ServiceWoker?

Если запрос выполняется впервые, Service Worker дает ему дойти до сервера и сохраняет полученный ответ. При последующем таком запросе скрипт уже сам отдаст данные из кэша.

* Какие есть ограничения в работе Service Woker?

Работа только на localhost либо по протоколу HTTPS, поддерживаемость далеко не всеми браузерами, а также необходимость заново загружать контент как минимум каждые 24 часа, чтобы предотвратить использование старой версии кода клиентом.

## 2. IndexedDB

**Ответы на вопросы:**

* Каким типом хранилища является IndexedDB?

IndexedDB является стандартом хранения структурированных данных на стороне клиента типа ключ/значенийе (база данных noSQL), которое считается окончательным решением для хранения данных в браузерах.

* Какая последовательность работы с хранилищем?

Обычная последовательность шагов при работе с IndexedDB :

1. Открыть базу данных.
2. Создать хранилище объектов в базе данных, над которой будут выполняться наши операции.
3. Запустить транзакцию и выдать запрос на выполнение какой-либо операции с базой данных, например, добавление или извлечение данных.
4. Ждать завершения операции, “слушая” событие DOM, на которое должен быть установлен обработчик.
5. Сделать что-то с результатами (которые могут быть найдены в возвращаемом по нашему запросу объекте).

* Какой жизненный цикл хранилища?

Открытие БД -> Создание хранилища -> Некоторая работа -> Удаление хранилища -> Удаление БД.

* Будет ли доступна информация из хранилища при закрытии веб-приложения? Если нет – какой тип хранилища надо использовать?

Да, будет, так как база данных хранится локально, и поэтому при отсутствии сети пользователь может получить эти локально сохраненные данные.

* Будет ли доступно хранилище двум одновременно открытым экземплярам веб-приложения? Почему?

Концепция IndexedDB гарантирует атомарность транзакций. К тому же данное хранилище - асинхронное. Всё это позволяет поддерживать доступность хранилища двум и более одновременно открытым экземплярам приложения.

## 3. LocalStorage, sessionStorage

**Ответы на вопросы:**

